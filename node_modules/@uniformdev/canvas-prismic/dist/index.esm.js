var I=class{constructor(e){this._clients={},Array.isArray(e)?e.forEach(t=>this.addClient(t)):e&&this.addClient(e)}addClient({source:e="default",client:t}){if(this._clients[e])throw new Error(`The source '${e}' is already registered`);if(!t)throw new Error("You must provide a Prismic client for the PrismicClientList");this._clients[e]={client:t}}getClient({source:e="default"}){let t=this._clients[e];if(!!t)return t.client}};var R=Object.freeze(["prismicEntry"]);function E(r){var t;let e=r;return Boolean(e.type===R[0]&&((t=e.value)==null?void 0:t.entryId))}function x(r){return Boolean(r==null?void 0:r.entryId)}import{createBatchEnhancer as V,UniqueBatchEntries as Q,createLimitPolicy as $}from"@uniformdev/canvas";import w from"@prismicio/client";function O({clients:r,addEntryQueryOptions:e,addBatchQueryOptions:t,useBatching:f,limitPolicy:P}){if(!r)throw new Error("No Prismic clients were provided to the enhancer. You must provide at least one client via the PrismicClientList.");let m=P||$({throttle:!1});return f?V({handleBatch:async l=>{var h;let u=l.reduce((n,s)=>{let{parameter:p,parameterName:o,component:i,context:y}=s.args,c=p.value;if(!x(c))return n;let d=v({parameterValue:c,parameterName:o,clients:r,component:i,context:y}),{source:a="default"}=c;return n[a]&&Array.isArray(n[a].tasks)?n[a].tasks.push(s):n[a]={client:d,tasks:[s]},n},{});try{console.time("fetch all entries");for await(let[n,s]of Object.entries(u)){let{context:p}=s.tasks[0].args,o=new Q(s.tasks,a=>a.parameter.value.entryId),i=await s.client,y=Object.keys(o.groups),c={expression:w.Predicates.in("document.id",y),options:{lang:"*",pageSize:100}},d=(h=t==null?void 0:t({entryIds:y,defaultBatchQuery:{...c},context:p}))!=null?h:c;console.time(`fetch entries ${n}`);try{let a=await i.query(d.expression,d.options),C=D(a);for await(let g of C)o.resolveKey(g.id,g);o.resolveRemaining(null)}finally{console.timeEnd(`fetch entries ${n}`)}}console.timeEnd("fetch all entries")}catch(n){let p=(i=>`Failed loading Prismic entries batch (${l.length}): ${i}`)(n.message),o=new Error(p);l.forEach(i=>i.reject(o))}},shouldQueue:({parameter:l})=>E(l),limitPolicy:m}):{enhanceOne:async function({parameter:u,parameterName:h,component:n,context:s}){var p;if(E(u)){if(!x(u.value))return null;let o=v({clients:r,parameterName:h,parameterValue:u.value,component:n,context:s}),i=u.value.entryId,y={expression:w.Predicates.at("document.id",i),options:{lang:"*"}},c=(p=e==null?void 0:e({parameter:u,parameterName:h,component:n,entryId:i,defaultQuery:y,context:s}))!=null?p:y;try{return console.time(`fetch entry ${i}`),await o.queryFirst(c.expression,c.options)}catch(d){let C=(g=>{var A;return`Failed loading Prismic entry '${i}' from source '${(A=u.value.source)!=null?A:"default"}' referenced in parameter '${h}': ${g}`})(d.message);throw new Error(C)}finally{console.timeEnd(`fetch entry ${i}`)}}},limitPolicy:m}}function v({clients:r,parameterValue:e,parameterName:t,component:f}){let{source:P="default"}=e,m=r.getClient({source:P});if(!m)throw new Error(`No Prismic client could be resolved for source key '${P}' referenced in parameter '${t} in component '${f.type}'. Ensure that the 'clients' property you are passing to the enhancer has a client instance registered for the source key.`);return m}async function*D(r){var f;let e=(f=r.results)!=null?f:[];for(let P of e)yield P;let t=r.next_page;for(;t;){let m=await(await fetch(t)).json();for(let l of m.results)yield l;t=m.next_page}}export{R as CANVAS_PRISMIC_PARAMETER_TYPES,I as PrismicClientList,O as createPrismicEnhancer,x as isParameterValueDefined,E as parameterIsPrismicEntry};
