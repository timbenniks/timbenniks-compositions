var b=Object.create;var E=Object.defineProperty;var _=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var B=Object.getPrototypeOf,M=Object.prototype.hasOwnProperty;var V=e=>E(e,"__esModule",{value:!0});var S=(e,t)=>{V(e);for(var r in t)E(e,r,{get:t[r],enumerable:!0})},T=(e,t,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of k(t))!M.call(e,s)&&s!=="default"&&E(e,s,{get:()=>t[s],enumerable:!(r=_(t,s))||r.enumerable});return e},Q=e=>T(V(E(e!=null?b(B(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);S(exports,{CANVAS_PRISMIC_PARAMETER_TYPES:()=>D,PrismicClientList:()=>$,createPrismicEnhancer:()=>N,isParameterValueDefined:()=>A,parameterIsPrismicEntry:()=>x});var $=class{constructor(t){this._clients={},Array.isArray(t)?t.forEach(r=>this.addClient(r)):t&&this.addClient(t)}addClient({source:t="default",client:r}){if(this._clients[t])throw new Error(`The source '${t}' is already registered`);if(!r)throw new Error("You must provide a Prismic client for the PrismicClientList");this._clients[t]={client:r}}getClient({source:t="default"}){let r=this._clients[t];if(!!r)return r.client}};var D=Object.freeze(["prismicEntry"]);function x(e){var r;let t=e;return Boolean(t.type===D[0]&&((r=t.value)==null?void 0:r.entryId))}function A(e){return Boolean(e==null?void 0:e.entryId)}var g=Q(require("@uniformdev/canvas")),I=Q(require("@prismicio/client"));function N({clients:e,addEntryQueryOptions:t,addBatchQueryOptions:r,useBatching:s,limitPolicy:y}){if(!e)throw new Error("No Prismic clients were provided to the enhancer. You must provide at least one client via the PrismicClientList.");let l=y||(0,g.createLimitPolicy)({throttle:!1});return s?(0,g.createBatchEnhancer)({handleBatch:async u=>{var h;let p=u.reduce((n,o)=>{let{parameter:P,parameterName:c,component:i,context:d}=o.args,a=P.value;if(!A(a))return n;let f=L({parameterValue:a,parameterName:c,clients:e,component:i,context:d}),{source:m="default"}=a;return n[m]&&Array.isArray(n[m].tasks)?n[m].tasks.push(o):n[m]={client:f,tasks:[o]},n},{});try{console.time("fetch all entries");for await(let[n,o]of Object.entries(p)){let{context:P}=o.tasks[0].args,c=new g.UniqueBatchEntries(o.tasks,m=>m.parameter.value.entryId),i=await o.client,d=Object.keys(c.groups),a={expression:I.default.Predicates.in("document.id",d),options:{lang:"*",pageSize:100}},f=(h=r==null?void 0:r({entryIds:d,defaultBatchQuery:{...a},context:P}))!=null?h:a;console.time(`fetch entries ${n}`);try{let m=await i.query(f.expression,f.options),w=j(m);for await(let C of w)c.resolveKey(C.id,C);c.resolveRemaining(null)}finally{console.timeEnd(`fetch entries ${n}`)}}console.timeEnd("fetch all entries")}catch(n){let P=(i=>`Failed loading Prismic entries batch (${u.length}): ${i}`)(n.message),c=new Error(P);u.forEach(i=>i.reject(c))}},shouldQueue:({parameter:u})=>x(u),limitPolicy:l}):{enhanceOne:async function({parameter:p,parameterName:h,component:n,context:o}){var P;if(x(p)){if(!A(p.value))return null;let c=L({clients:e,parameterName:h,parameterValue:p.value,component:n,context:o}),i=p.value.entryId,d={expression:I.default.Predicates.at("document.id",i),options:{lang:"*"}},a=(P=t==null?void 0:t({parameter:p,parameterName:h,component:n,entryId:i,defaultQuery:d,context:o}))!=null?P:d;try{return console.time(`fetch entry ${i}`),await c.queryFirst(a.expression,a.options)}catch(f){let w=(C=>{var R;return`Failed loading Prismic entry '${i}' from source '${(R=p.value.source)!=null?R:"default"}' referenced in parameter '${h}': ${C}`})(f.message);throw new Error(w)}finally{console.timeEnd(`fetch entry ${i}`)}}},limitPolicy:l}}function L({clients:e,parameterValue:t,parameterName:r,component:s}){let{source:y="default"}=t,l=e.getClient({source:y});if(!l)throw new Error(`No Prismic client could be resolved for source key '${y}' referenced in parameter '${r} in component '${s.type}'. Ensure that the 'clients' property you are passing to the enhancer has a client instance registered for the source key.`);return l}async function*j(e){var s;let t=(s=e.results)!=null?s:[];for(let y of t)yield y;let r=e.next_page;for(;r;){let l=await(await fetch(r)).json();for(let u of l.results)yield u;r=l.next_page}}0&&(module.exports={CANVAS_PRISMIC_PARAMETER_TYPES,PrismicClientList,createPrismicEnhancer,isParameterValueDefined,parameterIsPrismicEntry});
