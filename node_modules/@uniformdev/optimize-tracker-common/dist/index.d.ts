import { Scope, IntentVector, IntentAxis, DeliveryAPIResult, Signal, DeliveryIntent, IntentTagStrength, IntentTags } from '@uniformdev/optimize-common';

/** Top level definition of tracker storage of all types */
interface TrackerStorage {
    tests: TestStorage;
    scopes: ScopeStorage;
}
/** Stores tracker scopes (sets of metadata with different longevities, like visit vs visitor) */
interface ScopeStorage {
    /** Identifier for this storage type. Used for diagnostic purposes. */
    id: string;
    getScope(type: Scope | string): Promise<Readonly<TrackerScope> | undefined>;
    setScope(scope: TrackerScope): Promise<void>;
    getScoring: (scope: Scope | string) => Promise<Readonly<TrackerScoring> | undefined>;
    setScoring: (scoring: TrackerScoring | undefined, scope: Scope | string, expirationMinutes?: number, previousScoring?: TrackerScoring, scoreDifference?: IntentVector) => Promise<void>;
    /**
     * Called when a visitor has been identified (i.e. by logging in, etc).
     * This is a write-only value, and it is not expected for storage to persistently store this for retrieval.
     * Used to combine storage across devices for the same identified visitor.
     * Optional implementation.
     */
    identify?: (identifier: string) => Promise<Readonly<TrackerScoring> | undefined>;
    /**
     * Callback that is set by the tracker which can be invoked to signal that the scope data has been changed _outside_ the tracker.
     * Will cause the tracker to broadcast the updated scores to listeners.
     * IMPORTANT: invoke this only due to _external_ score updates such as background refreshing, not for setScoring() calls.
     */
    setScoringValueExternallyUpdatedCallback?: (cb: TrackerScoringValueCallback) => void;
    /**
     * Deletes all data stored about scopes
     * @param onAllDevices whether to delete data that could be shared with other devices (i.e. an identified profile). Defaults to false.
     * */
    delete(onAllDevices?: boolean): Promise<void>;
}
declare type TrackerScoringValueCallback = (scope: Scope | string, scoring: TrackerScoring) => Promise<void>;
/** Subset of ScopeStorage used by scope storage providers that allow delegating scoring storage elsewhere (i.e. idb) */
declare type ScoringStorage = Pick<ScopeStorage, 'getScoring' | 'setScoring' | 'delete'>;
interface TestStorage {
    /** Identifier for this storage type. Used for diagnostic purposes. */
    id: string;
    getTestSelection: (testId: string) => Promise<string | undefined>;
    setTestSelection: (testId: string, value: string | undefined) => Promise<void>;
    delete(): Promise<void>;
}
interface TrackerScope {
    id: string;
    type: Scope | string;
    created: number;
    updated?: number;
    state: TrackerScopeState;
    random: number;
    statistics?: Record<string, SignalStatistics>;
}
declare type TrackerScopeState = {
    /** Store data on signal level for this scope */
    signals?: Record<string, any>;
};
interface SignalStatistics {
    evaluations: number;
}

interface Tracker {
    /** Initializes the tracker, freezing its configuration and making it ready for use */
    initialize(): Promise<void>;
    /** Checks if the initialize() process has completed */
    isInitialized(): boolean;
    /** Gets current visitor intent scores for all intents they have a score in */
    getIntentStrength(scope?: Scope | string): Promise<IntentVector | undefined>;
    /** Gets current visitor intent score in a single intent. Returns undefined if visitor has no score in the intent. */
    getIntentStrengthSingle(intent: string): Promise<IntentAxis | undefined>;
    /**
     * Programmatically add strength to intent(s), bypassing signals.
     * Favor using signals to modify intent strength whenever possible.
     */
    addIntentStrength(scope: Scope | string, valueToAdd: IntentVector): Promise<void>;
    /**
     * Programmatically set intent strength, bypassing signals.
     * Favor using signals to modify intent strength whenever possible.
     */
    setIntentStrength(scope: Scope | string, valueToSet: IntentVector): Promise<void>;
    /** Removes all strength in a specific intent, programmatically. */
    removeIntent(intent?: string | string[], options?: {
        scope?: Scope | string;
        quiet?: boolean;
    }): Promise<boolean>;
    addScoringChangeListener(listener: ListenerFunction): void;
    removeScoringChangeListener(listener: ListenerFunction): void;
    /** Re-evaluates the presence of signals and records signals that are present. This is called automatically when the tracker initializes; a common use case after that is when client-side routes change. */
    reevaluateSignals(requestContext?: TrackerRequestContext): Promise<ReevaluateSignalsResults>;
    /** Adds an activity that had a behavior weight mapping associated with it. This behavior will be recorded once reevaluateSignals() is called.
     * @param biasing The behavior intent vector to record. This vector is diluted by any additional behaviors in the queue when reevaluation is occurred.
     * @param sourceKey A key that can be set to prevent recording the same behavior source more than once per re-evaluation. If the same key is added more than once, only the last one is actually tracked.
     */
    addBehaviorActivity(biasing: IntentVector, sourceKey?: string): void;
    /** Pushes a programmatic event (such as a Google Analytics event) into the tracker. If this event matches a signal, scoring may be updated. */
    addEvent(event: TrackerEvent, options?: TrackerPushEventOptions): Promise<void>;
    /**
     * Get the values that have been pushed for this enrichment.
     * @param {string} enrichmentName - Name of the enrichment to retrieve the values for
     * @param {GetEnrichmentValuesOptions} options - Options for enrichment value retrieval
     */
    getEnrichmentValues(enrichmentName: string, options?: GetEnrichmentValuesOptions): Promise<Record<string, number> | undefined>;
    /**
     * Add enrichment value(s) into the tracker.
     * @param {TrackerEnrichment | TrackerEnrichment[]} enrichment - Enrichments to push into the tracker
     * @param {AddEnrichmentOptions} options - Options for adding enrichments
     */
    addEnrichment(enrichment: TrackerEnrichment | TrackerEnrichment[], options?: AddEnrichmentOptions): Promise<void>;
    /**
     * Remove values of an enrichment from the tracker
     * @param {string} enrichmentName - Name of the enrichment to remove values of
     * @param {RemoveEnrichmentOptions} options - Options for removing enrichment values
     */
    removeEnrichment(enrichmentName: string, options?: RemoveEnrichmentOptions): Promise<void>;
    /** Triggers `track` on plugins that expose the function, utilized for analytics. */
    trackPersonalization(name: string, payload: AnalyticsEventPayload): void;
    /**
     * Check if the current visitor is receiving personalization,
     * or is part of a control group not receiving personalization.
     * false = receiving personalization, true = control group.
     */
    isInPersonalizationControlGroup(options?: TrackerTestCheckOptions): Promise<boolean>;
    /**
     * Retrieves the selected variant ID from storage if one has been calculated previously.
     * @param testId - ID of the test to find selected variant of
     */
    getTestValue(testId: string): Promise<string | undefined>;
    /**
     * Persists the selected variant ID to storage for the specified test ID
     * @param testId - The ID of the test to set the selected variant ID
     * @param selectedVariantId - The selected variant ID for the test
     */
    setTestValue(testId: string, selectedVariantId: string | undefined): Promise<void>;
    /**
     * Check if a test is registered in the intent manifest and should be enabled.
     * @param testId - ID of the test to check if enabled
     */
    isTestEnabled(testId: string): boolean;
    /**
     * Identifies the current visitor to storage.
     * Requires a scope storage implementation that uses identification.
     * The value cannot be retrieved; to store the identifier use something else.
     */
    identify(identifier: string): Promise<void>;
    /**
     * Forgets all data about the current visitor
     * @param onAllDevices whether to delete data that could be shared with other devices (i.e. an identified profile). Defaults to false.
     */
    forgetMe(onAllDevices?: boolean): Promise<void>;
    /**
     * Retrieves server state, if available, from the __UNIFORM_DATA__ script tag
     */
    getServerState(): Readonly<ServerState> | undefined;
    /** Logs a message to the tracker log */
    log(data: LogMessageOptions): void;
}
interface RemoveEnrichmentOptions {
    /** The scope to remove enrichments on */
    scope?: Scope;
    /** Suppress the broadcasting of recalculated scores after removal */
    quiet?: boolean;
}
interface AddEnrichmentOptions {
    /** The scope to add enrichments on */
    scope?: Scope;
    /** Suppress the broadcasting of recalculated scores after removal */
    quiet?: boolean;
    /** Clear other values for this enrichment */
    clearValues?: boolean;
}
interface GetEnrichmentValuesOptions {
    /** The scope to get enrichments for */
    scope?: Scope;
}
interface TrackerTestCheckOptions {
    scope?: Scope | string;
    sampleSize?: number;
}
interface ServerState {
    scoring: IntentVector | undefined;
    tests?: Record<string, string>;
}
interface ReevaluateSignalsResults {
    scoring?: IntentVector | undefined;
    signalMatches: Record<string, EvaluatedSignal[]>;
}
interface EvaluatedSignal {
    intentId: string;
    signalType: string;
    signalStrength: number;
}
interface TrackerPlugins {
    findPlugins(type: keyof TrackerPlugin): TrackerPlugin[];
    find<TFunction>(type: keyof TrackerPlugin): TFunction[];
    log(callback: (func: LogMessageFunction) => void): void;
    track(callback: (func: TrackFunction) => void): void;
    initialize(callback: (func: InitializeFunction) => Promise<void> | void): Promise<void>;
    scoringChange(callback: (func: ScoringChangeListener) => void): void;
}
interface TrackerScopes {
    visit?: TrackerScopeStrategy;
    visitor?: TrackerScopeStrategy;
    [k: string]: TrackerScopeStrategy | undefined;
}
/** Options that can be passed when creating the tracker to configure it. */
interface TrackerOptions {
    intentManifest?: DeliveryAPIResult;
    plugins?: TrackerPlugins;
    scoring?: TrackerScoringStrategy;
    decay?: TrackerDecayStrategy;
    storage: TrackerStorage;
    scopes: TrackerScopes;
    testing?: TrackerTestSettings | TrackerTestSettings[];
}
declare type InitializeFunction = (options: InitializeOptions) => Promise<void> | void;
declare type LogMessageFunction = (data: LogMessageOptions) => void;
declare type SignalEvaluatorMappingFunction = () => Record<string, SignalEvaluator<any>>;
declare type TrackFunction = (eventName: string, payload: AnalyticsEventPayload) => Promise<boolean>;
declare type GetStateFunction = () => any;
declare type PageViewFunction = (pageView: {
    path: string;
    visitId: string | undefined;
}) => void;
/** Defines the interface for a tracker plugin. Plugins can respond to tracker events to provide services from storage to logging. */
interface TrackerPlugin {
    /** Plugin name, used for logging and debugging. Value is arbitrary. */
    name: string;
    /** Initializes the plugin. If false is returned, the plugin is disabled. */
    initialize?: InitializeFunction;
    /** Function invoked whenever the scoring of the visitor changes. */
    onScoringChange?: ScoringChangeListener;
    /** Function invoked when the tracker logs a message */
    onLogMessage?: LogMessageFunction;
    /** Function invoked when the tracker is trying to evaluate a signal to determine its current strength */
    signalEvaluatorMapping?: SignalEvaluatorMappingFunction;
    /**
     * Function invoked when an analytics event is triggered.
     * @param {string} eventName - Name of the analytics event being triggered.
     * @param {AnalyticsEventPayload} payload - Event data for analytics event.
     */
    track?: TrackFunction;
}
/** Defines the structure for analytics events. */
declare type AnalyticsEventPayload = {
    /** Category for analytics event */
    category: string;
    /** Description of the event */
    label: string;
    /** Value of the event */
    value?: any;
    /** The scores that lead to this result */
    intentScores?: IntentVector;
    /** Whether or not this event came from a user interaction */
    interaction?: boolean;
};
declare type ListenerFunction = (value: IntentVector | null) => void;
/** Event handler function that is called when tracker scoring changes */
declare type ScoringChangeListener = (value: IntentVector | null) => void;
declare type ScopeStrategyInitializeOptions = {
    log: LogFunction;
    storage: ScopeStorage;
};
/** Manages expiration for a single TrackerScope stored in a ScopeStorage */
interface TrackerScopeStrategy {
    type: Scope | string;
    initialize: (options: ScopeStrategyInitializeOptions) => Promise<void>;
    get: () => Promise<Readonly<TrackerScope> | undefined>;
    save: (scope: TrackerScope) => Promise<void>;
    getExpiration: () => number | undefined;
}
/** Data stored for a visitor in the tracker */
interface TrackerStorageData {
    pluginState: Record<string, any>;
}
interface TrackerScoring {
    updated: number;
    values: IntentVector;
    strategy: string;
}
/** The strategy to use then updating scoring for a visitor */
declare type TrackerScoringStrategy = (data: ScoringStrategyOptions) => TrackerScoring;
/** The strategy to use when starting a new visit to decay values from previous visits */
declare type TrackerDecayStrategy = (existingData?: Partial<TrackerScoring>) => Promise<TrackerScoring | undefined>;
/** The log levels that can be used by the tracker. Based on npm levels. */
declare type TrackerLogLevels = 'error' | 'warn' | 'info' | 'verbose';
interface ScoringStrategyOptions {
    previousValue: IntentVector;
    valueToAdd: IntentVector;
    signalCount: number;
}
interface SaveDataOptions {
    data: TrackerStorageData;
}
interface LogMessageOptions {
    level: TrackerLogLevels;
    message: string;
    region?: string;
    [k: string]: any;
}
declare type LogFunction = (options: LogMessageOptions) => void;
declare type InitializeOptions = Pick<Tracker, 'log' | 'setIntentStrength'> & {
    manifest: DeliveryAPIResult;
};
/** A handler that evaluates a signal to determine its current strength. Returns the current strength, 0-100, or undefined if there is no match. */
declare type SignalEvaluator<T, TOptions extends SignalEvaluatorOptions<T> = SignalEvaluatorOptions<T>> = (options: TOptions) => Promise<SignalEvaluatorResult<T> | undefined> | SignalEvaluatorResult<T> | undefined;
interface SignalEvaluatorOptions<T> {
    state?: Partial<T>;
    signal: Signal;
    intent: DeliveryIntent;
    behaviors: IntentVector[];
    requestContext?: TrackerRequestContext | null;
    events: TrackerEvent[];
    log?: LogFunction;
}
interface SignalEvaluatorResult<T> {
    state?: T;
    strength?: number;
}
interface TrackerRequestContext {
    url: string;
    cookies?: string;
    userAgent?: string;
}
interface TrackerEvent {
    label: string;
    value?: string;
    category?: string;
}
interface TrackerPushEventOptions {
    quiet?: boolean;
}
interface TrackerTestStrategy {
    isInPersonalizationControlGroup: (scope: TrackerScope | undefined, sampleSize?: number) => boolean;
}
interface TrackerTestSettings {
    endDate?: Date;
    strategy: TrackerTestStrategy;
}
declare type TrackerEnrichment = {
    name: string;
    value: string;
    str?: IntentTagStrength | number;
};

declare type AnalyticsMetaData = {
    matches: string[];
    isInPersonalizationControlGroup: boolean;
    intentScores: IntentVector;
};
declare type AnalyticsEventEmitterOptions = {
    tracker?: Tracker | null;
    name: string;
};
declare type AnalyticsEventEmitter = {
    personalization(data: AnalyticsMetaData): boolean;
    test({ testName, testSelection }: {
        testName: string;
        testSelection: string | undefined;
    }): boolean;
};

declare type PersonalizeListFunction = <T extends PersonalizableListItem>(options: ListPersonalizerArguments<T>) => ListPersonalizationResult<T>;
/** Function that can take a list of personalizable variants or items, and return them ranked by relevancy to intent scores.
 * This ranking can then be used to order the list, choose the most relevant variant(s) to use, etc.
 */
declare type ListPersonalizer<TListItem extends PersonalizableListItem> = (data: ListPersonalizerArguments<TListItem>) => ListPersonalizationResult<TListItem>;
declare type ListPersonalizationScorer = (data: ScorerArguments) => {
    /** The relevancy of this item. HIGHER numbers are more relevant. If a score cannot be calculated return zero. */
    score: number;
    /** The strength of the intent tag matches. Higher numbers are stronger. Used to tiebreak if the score is the same between variations. Return zero to ignore. */
    tagStrength: number;
    /** Whether this item is default. Default items have no personalization data applied to them. */
    isDefault: boolean;
    /** Intent(s) that caused the match */
    matches?: string[];
};
/** @deprecated 'use string values instead' */
declare enum MatchFilter {
    /** Personalized matches, default variations, and personalizations that do not match */
    Any = 0,
    /** Personalized matches only. Default variations will not be shown. */
    PersonalizedOnly = 1,
    /** Personalized matches or default variations only. Non-matching personalized variations are rejected. */
    PersonalizedOrDefault = 2
}
interface ListPersonalizerListData<TListItem extends PersonalizableListItem> {
    /** The variations to sort in personalized-order */
    list: TListItem[];
    /** The number of variations to select. Use for personalized lists where the `count` most relevant should be shown. */
    count?: number;
    /** Controls what can be present in the personalized result. Default: PersonalizedOrDefault */
    matchFilter?: 'any' | 'personalizedOnly' | 'personalizedOrDefault' | MatchFilter;
}
interface ListPersonalizerArguments<TListItem extends PersonalizableListItem> extends ListPersonalizerListData<TListItem> {
    intentScores: IntentVector;
    isInPersonalizationControlGroup?: boolean;
    scorer?: ListPersonalizationScorer;
    fallbackSort?: (a: TListItem, b: TListItem) => number;
    analyticsEmitter?: AnalyticsEventEmitter;
}
interface ScorerArguments {
    intentTag?: IntentTags | null;
    intentScores?: IntentVector;
}
/** Function that  */
declare type ListMapper<T> = (list: T[]) => (T & PersonalizableListItem)[];
/** An item in any list that may be personalized (contain intent tag data) */
interface PersonalizableListItem {
    /** Type of list item. Type is only required when component generation using Personalize component */
    type?: string | null;
    /** Intent tag associated with this list item. Items without intent tags will be considered default. */
    intentTag: IntentTags | undefined | null;
}
interface ListPersonalizationResultItem<T> {
    item: T;
    isDefault: boolean;
    relevancy: number;
    tagStrength: number;
    matches?: string[];
}
/** The result of personalizing a list of PersonalizableListItems */
interface ListPersonalizationResult<T> {
    /** The list, sorted by personalization relevancy */
    result: ListPersonalizationResultItem<T>[];
    /** Whether personalization occurred */
    personalized: boolean;
    /** What intent scores lead to this personalization */
    intentScores: IntentVector | null | undefined;
}

declare const EdgeNodeTagName = "nesitag";
declare enum ScriptType {
    ListStart = "nesi-list-start",
    ListEnd = "nesi-list-end",
    ListItem = "nesi-list-item-html",
    ListItemSettings = "nesi-list-item-settings",
    TestStart = "nesi-test-start",
    TestEnd = "nesi-test-end",
    Unknown = "unknown"
}
declare const PageStateScriptType = "page-state-script";
declare type ScriptListFragment = {
    opening: {
        start: number;
        end: number;
    };
    end: number;
    contents: string | undefined;
    type: ScriptType;
};
declare type TestListFragmentSettings = {
    id: string;
};
declare type ScriptListFragmentSettings = {
    intentTag: IntentTags | null | undefined;
};
declare type BaseList<TOptions, TSettings> = {
    type: 'scriptlist' | 'testlist';
    items: string[];
    settings: TSettings[];
    options?: TOptions;
};
declare type EdgeList = BaseList<EdgeTestComponentProps | EdgeListComponentProps, TestListFragmentSettings | ScriptListFragmentSettings>;
declare const isTestList: (base: EdgeList) => base is EdgeTestList;
declare const isScriptList: (base: EdgeList) => base is EdgeScriptList;
declare type EdgeTestList = BaseList<EdgeTestComponentProps, TestListFragmentSettings> & {
    type: 'testlist';
};
declare type EdgeScriptList = BaseList<EdgeListComponentProps, ScriptListFragmentSettings> & {
    type: 'scriptlist';
};
declare type EdgeTestComponentProps = {
    name: string;
};
declare type EdgeListComponentProps = {
    count?: number;
    matchFilter?: ListPersonalizerArguments<any>['matchFilter'];
};
declare type EdgeRenderedComponent = {
    intentTag: IntentTags | undefined | null;
    html: string;
};
declare type EdgeListData = {
    components: EdgeRenderedComponent[];
    options?: EdgeListComponentProps;
};

declare enum ExtensionEvents {
    SetScores = "uniform-in:set_scores",
    Log = "uniform:log",
    SetLogLevel = "uniform-in:set_loglevel",
    Score = "uniform:scores",
    Hello = "uniform:hello"
}
declare type ExtensionEventData = {
    type: ExtensionEvents;
};
/** A log message emitted as an event to the browser extension */
interface ExtensionLogMessage extends ExtensionEventData {
    type: ExtensionEvents.Log;
    message: LogMessageOptions;
}
declare const isExtensionLogMessage: (event: ExtensionEventData) => event is ExtensionLogMessage;
/** A score changed message emitted as an event to the browser extension */
interface ExtensionScoreMessage extends ExtensionEventData {
    type: ExtensionEvents.Score;
    score: IntentVector;
}
/** A hello message emitted as an event from the browser extension to test if the page contains Optimize */
interface ExtensionHelloMessage extends ExtensionEventData {
    type: ExtensionEvents.Hello;
    manifest: DeliveryAPIResult;
}
/** A score set message emitted as an event from the browser extension (for previewing) */
interface ExtensionSetScoreMessage extends ExtensionEventData {
    type: ExtensionEvents.SetScores;
    score: IntentVector;
}
/** A score set message emitted as an event from the browser extension (for previewing) */
interface ExtensionSetScoreMessage extends ExtensionEventData {
    type: ExtensionEvents.SetScores;
    score: IntentVector;
}
declare const isExtensionSetScoreMessage: (event: ExtensionEventData) => event is ExtensionSetScoreMessage;

declare type TestVariant = {
    /** The identifier for this variant. This value persisted to storage when a variant is selected. */
    id: string;
    /** Type of variant. Type is only required when component generation using Test component */
    type?: string | null;
    /** A number between 0 and 100 representing what percentage of visitors will be selected for this variant.
     * If not provided, this variant will be selected equally. */
    distribution?: number;
};
declare type ListTestArguments<T extends TestVariant> = {
    /** Name of the test that is running. */
    testName: string;
    /** Variation list that this test will selected from. */
    variations: T[];
    /** A random number between 0 and 100 that will be used to select variants. */
    random: number;
    /** Force the selection of a particular variant, if ID is not present, will select a new variant based on provided random number. */
    selectedVariantId?: string;
    /** Emitter to trigger analytics events on. */
    analyticsEmitter?: AnalyticsEventEmitter;
};
declare type ListTestResult<T extends TestVariant> = {
    /** The selected variant from a test execution. */
    result: T | undefined;
    /** Whether or not analytics were tracked for this execution. */
    tracked: boolean;
};
declare type TestListFunction = <T extends TestVariant>(options: ListTestArguments<T>) => ListTestResult<T>;

export { AddEnrichmentOptions, AnalyticsEventEmitter, AnalyticsEventEmitterOptions, AnalyticsEventPayload, AnalyticsMetaData, BaseList, EdgeList, EdgeListComponentProps, EdgeListData, EdgeNodeTagName, EdgeRenderedComponent, EdgeScriptList, EdgeTestComponentProps, EdgeTestList, EvaluatedSignal, ExtensionEventData, ExtensionEvents, ExtensionHelloMessage, ExtensionLogMessage, ExtensionScoreMessage, ExtensionSetScoreMessage, GetEnrichmentValuesOptions, GetStateFunction, InitializeFunction, InitializeOptions, ListMapper, ListPersonalizationResult, ListPersonalizationResultItem, ListPersonalizationScorer, ListPersonalizer, ListPersonalizerArguments, ListPersonalizerListData, ListTestArguments, ListTestResult, ListenerFunction, LogFunction, LogMessageFunction, LogMessageOptions, MatchFilter, PageStateScriptType, PageViewFunction, PersonalizableListItem, PersonalizeListFunction, ReevaluateSignalsResults, RemoveEnrichmentOptions, SaveDataOptions, ScopeStorage, ScopeStrategyInitializeOptions, ScorerArguments, ScoringChangeListener, ScoringStorage, ScoringStrategyOptions, ScriptListFragment, ScriptListFragmentSettings, ScriptType, ServerState, SignalEvaluator, SignalEvaluatorMappingFunction, SignalEvaluatorOptions, SignalEvaluatorResult, SignalStatistics, TestListFragmentSettings, TestListFunction, TestStorage, TestVariant, TrackFunction, Tracker, TrackerDecayStrategy, TrackerEnrichment, TrackerEvent, TrackerLogLevels, TrackerOptions, TrackerPlugin, TrackerPlugins, TrackerPushEventOptions, TrackerRequestContext, TrackerScope, TrackerScopeState, TrackerScopeStrategy, TrackerScopes, TrackerScoring, TrackerScoringStrategy, TrackerScoringValueCallback, TrackerStorage, TrackerStorageData, TrackerTestCheckOptions, TrackerTestSettings, TrackerTestStrategy, isExtensionLogMessage, isExtensionSetScoreMessage, isScriptList, isTestList };
