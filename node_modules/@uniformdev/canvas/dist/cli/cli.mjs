import{d as p,m as H,n as z}from"../chunk-Y7BBT5AF.mjs";import Ne from"yargs";import Me from"yargs";import{dump as pe,load as de}from"js-yaml";import{writeFileSync as le}from"fs";import{extname as V}from"path";import{readFileSync as fe}from"fs";import ge from"p-limit";function d(e){var o,t;return e.option("apiKey",{describe:"Uniform API key. Defaults to CANVAS_CLI_API_KEY or UNIFORM_API_KEY env. Supports dotenv.",default:(t=(o=process.env.CANVAS_CLI_API_KEY)!=null?o:process.env.UPM_CLI_API_KEY)!=null?t:process.env.UNIFORM_API_KEY,demandOption:!0,type:"string"}).option("apiHost",{describe:"Uniform host. Defaults to UNIFORM_CLI_BASE_URL env or https://uniform.app. Supports dotenv.",default:process.env.UNIFORM_CLI_BASE_URL||"https://uniform.app",demandOption:!0,type:"string"})}function l(e){var o,t;return e.option("project",{describe:"Uniform project ID. Defaults to CANVAS_CLI_PROJECT_ID or UNIFORM_PROJECT_ID env. Supports dotenv.",default:(t=(o=process.env.CANVAS_CLI_PROJECT_ID)!=null?o:process.env.UPM_CLI_PROJECT_ID)!=null?t:process.env.UNIFORM_PROJECT_ID,demandOption:!0,type:"string",alias:["p"]})}function j(e){return e.option("format",{alias:["f"],describe:"Output format",default:"yaml",choices:["yaml","json"],type:"string"}).option("filename",{alias:["o"],describe:"Output filename. If not specified, write to stdout.",type:"string"})}function w(e){return e.option("diff",{describe:"Whether to show diffs in stdout. off = no diffs; update = on for updates; on = updates, creates, deletes",default:"off",type:"string",choices:["off","update","on"],alias:["d"]})}function O(e){let o=V(e);return o===".yaml"||o===".yml"||o===".json"}function h(e,o,t){let n;if(t&&!o){let i=V(t);i===".yaml"||i===".yml"?o="yaml":i===".json"&&(o="json")}else if(!o)throw new Error("Format must be specified when no filename is passed");switch(o){case"json":n=JSON.stringify(e,null,2);break;case"yaml":n=pe(e);break;default:throw new Error(`Unsupported format: ${o}`)}t?le(t,n,"utf8"):console.log(n)}function D(e){let o=fe(e,"utf8");return de(o,{filename:e,json:!0})}function W(e){let o={...e};return delete o.projectId,delete o.state,o}function S(e){return e.option("state",{type:"string",describe:"Composition state to fetch.",choices:["preview","published"],default:"preview"})}async function*$(e,o){let t=o.pageSize||100,n=0,i=[];do{i=await e(n,t);for(let s of i)yield s;n+=t}while(i.length===t)}function P(e){let o=Number(e);if(!isNaN(o))return o;if(!e)return z;if(typeof e!="string")throw new Error('state must be "published", "preview", or a number');return e==="preview"?H:z}var v=ge(8);import ue from"isomorphic-unfetch";var Y={command:"get <id>",describe:"Fetch a component definition",builder:e=>j(d(l(e.positional("id",{demandOption:!0,describe:"Component definition public ID to fetch"})))),handler:async({apiHost:e,apiKey:o,id:t,format:n,project:i,filename:s})=>{let r=await new p({apiKey:o,apiHost:e,fetch:ue,projectId:i}).getComponentDefinitions({componentId:t,limit:1});r.componentDefinitions.length===0?(console.error("Component did not exist"),process.exit(1)):h(r.componentDefinitions[0],n,s)}};import ye from"isomorphic-unfetch";var B={command:"list",describe:"List component definitions",aliases:["ls"],builder:e=>j(d(l(e.options({offset:{describe:"Number of rows to skip before fetching",type:"number",default:0},limit:{describe:"Number of rows to fetch",type:"number",default:20}})))),handler:async({apiHost:e,apiKey:o,limit:t,offset:n,format:i,filename:s,project:c})=>{let a=await new p({apiKey:o,apiHost:e,fetch:ye,projectId:c}).getComponentDefinitions({limit:t,offset:n});h(a.componentDefinitions,i,s)}};import Pe from"isomorphic-unfetch";import{diffJson as Ce,diffLines as q}from"diff";import be from"lodash.isequalwith";async function E({source:e,target:o,compareContents:t=(r,a)=>be(r.object,a.object,(m,g,u)=>u==="created"||u==="updated"?!0:void 0),mode:n,allowEmptySource:i=!1,whatIf:s=!1,log:c=()=>{}}){var g,u;let r=new Map;for await(let f of o.objects)r.set(f.id,f);let a=[],m=!1;for await(let f of e.objects){m=!0;let y=f.id,A=r.get(y);if(A){if(!t(f,A)&&(n==="createOrUpdate"||n==="mirror")){let b=async(C,R)=>{var N;s||await o.writeObject(C),c({action:"update",id:y,providerId:C.providerId,displayName:(N=C.displayName)!=null?N:C.providerId,whatIf:s,diff:Ce(R.object,C.object)})};a.push(b(f,A))}r.delete(y)}else{let b=async(C,R)=>{var N;s||await o.writeObject(C),c({action:"create",id:R,providerId:R,displayName:(N=C.displayName)!=null?N:C.providerId,whatIf:s,diff:q("",JSON.stringify(C.object,null,2))})};a.push(b(f,y))}}if(await Promise.all(a),n==="mirror"){if(!m&&!i)throw new Error("Source is empty and mode is mirror. This would cause deletion of everything in the target, and most likely indicates an error in source definition.");let f=[];r.forEach(async y=>{let A=async b=>{var C;s||await o.deleteObject(b.providerId),c({action:"delete",id:b.id,providerId:b.providerId,displayName:(C=b.displayName)!=null?C:b.providerId,whatIf:s,diff:q(JSON.stringify(b.object,null,2),"")})};f.push(A(y))}),await Promise.all(f)}await Promise.all([(g=e.onSyncComplete)==null?void 0:g.call(e,!1),(u=o.onSyncComplete)==null?void 0:u.call(o,!0)])}import Ae from"chalk";import{existsSync as he,mkdirSync as Se}from"fs";import{readdir as je,unlink as we}from"fs/promises";import{extname as Oe,join as Q}from"path";async function I({directory:e,format:o="yaml",selectIdentifier:t,selectDisplayName:n=t}){he(e)||Se(e,{recursive:!0});let s=await je(e,"utf-8"),c=new Set(s.filter(m=>{let g=Oe(m);return g===".json"||g===".yaml"||g===".yml"})),r=m=>Q(e,`${m}.${o}`);async function*a(){for(let m of c){let g=Q(e,m);try{let u=await D(g);yield{id:t(u),displayName:n(u),providerId:g,object:u}}catch(u){throw console.error(Ae.red(`Failed to read ${g}, data is likely invalid.
${u==null?void 0:u.message}`)),u}}}return{objects:a(),deleteObject:async m=>{await we(m)},writeObject:async m=>{h(m.object,o,r(m.id))}}}var M=e=>e.id,T=e=>`${e.name} (pid: ${e.id})`;function G({client:e}){async function*o(){let t=$(async(n,i)=>(await e.getComponentDefinitions({limit:i,offset:n})).componentDefinitions,{pageSize:100});for await(let n of t)yield{id:M(n),displayName:T(n),providerId:n.id,object:n}}return{objects:o(),deleteObject:async t=>{await e.removeComponentDefinition({componentId:t})},writeObject:async t=>{await e.updateComponentDefinition({componentDefinition:t.object})}}}import U from"chalk";function x({diffMode:e}){return function({action:t,displayName:n,whatIf:i,diff:s}){let c="";switch(t){case"create":c=U.green("[A]");break;case"update":c=U.white("[U]");break;case"delete":c=U.yellow("[D]");break}let r="";(e==="on"||e==="update"&&t==="update")&&(r=`
`+s.map(a=>a.added?U.green(a.value):a.removed?U.red(a.value):a.value).join("")),console.log(`${i?U.gray("[WHATIF]"):""}${c} ${n}${r}`)}}import De from"fs";function k(e,o){if(!o&&!De.existsSync(e))return{};let t=D(e);if(typeof t!="object")throw new Error(`Package ${e} does not appear valid.`);return t}function J(e,o){h(o,void 0,e)}async function F({objects:e,selectIdentifier:o,selectDisplayName:t=o,onSyncComplete:n}){let i=e.reduce((r,a)=>{let m=o(a);if(r[m])throw new Error(`Identifier ${m} was not unique.`);return r[m]={id:m,object:a,providerId:m,displayName:t(a)},r},{});async function*s(){for(let r of Object.values(i))yield r}function c(){return Object.entries(i).sort((r,a)=>r[0].localeCompare(a[0])).map(r=>r[1].object)}return{objects:s(),deleteObject:async r=>{delete i[r]},writeObject:async r=>{let a=o(r.object);i[a]=r},extractCurrent:c,onSyncComplete:n?r=>n(r,c()):void 0}}var X={command:"pull <directory>",describe:"Pulls all component definitions to local files in a directory",builder:e=>d(l(w(e.positional("directory",{describe:"Directory to save the component definitions to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",type:"string"}).option("format",{alias:["f"],describe:"Output format",default:"yaml",choices:["yaml","json"],type:"string"}).option("what-if",{alias:["w"],describe:"What-if mode reports what would be done but changes no files",default:!1,type:"boolean"}).option("mode",{alias:["m"],describe:'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',choices:["create","createOrUpdate","mirror"],default:"mirror",type:"string"})))),handler:async({apiHost:e,apiKey:o,directory:t,format:n,mode:i,whatIf:s,project:c,diff:r})=>{var f;let a=new p({apiKey:o,apiHost:e,fetch:Pe,projectId:c,limitPolicy:v}),m=G({client:a}),g;if(O(t)){let y=k(t,!1);g=await F({objects:(f=y.components)!=null?f:[],selectIdentifier:M,selectDisplayName:T,onSyncComplete:async(A,b)=>{y.components=b,J(t,y)}})}else g=await I({directory:t,selectIdentifier:M,selectDisplayName:T,format:n});await E({source:m,target:g,mode:i,whatIf:s,log:x({diffMode:r})})}};import ve from"isomorphic-unfetch";var Z={command:"push <directory>",describe:"Pushes all component definitions from files in a directory to Uniform Optimize",builder:e=>d(l(w(e.positional("directory",{describe:"Directory to read the component definitions from. If a filename is used, a package will be read instead.",type:"string"}).option("what-if",{alias:["w"],describe:"What-if mode reports what would be done but changes nothing",default:!1,type:"boolean"}).option("mode",{alias:["m"],describe:'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',choices:["create","createOrUpdate","mirror"],default:"mirror",type:"string"})))),handler:async({apiHost:e,apiKey:o,directory:t,mode:n,whatIf:i,project:s,diff:c})=>{var u;let r=new p({apiKey:o,apiHost:e,fetch:ve,projectId:s,limitPolicy:v}),a;if(O(t)){let f=k(t,!0);a=await F({objects:(u=f.components)!=null?u:[],selectIdentifier:M,selectDisplayName:T})}else a=await I({directory:t,selectIdentifier:M,selectDisplayName:T});let g=G({client:r});await E({source:a,target:g,mode:n,whatIf:i,log:x({diffMode:c})})}};import Ee from"isomorphic-unfetch";var ee={command:"remove <id>",aliases:["delete","rm"],describe:"Delete a component definition",builder:e=>d(l(e.positional("id",{demandOption:!0,describe:"Component definition public ID to delete"}))),handler:async({apiHost:e,apiKey:o,id:t,project:n})=>{await new p({apiKey:o,apiHost:e,fetch:Ee,projectId:n}).removeComponentDefinition({componentId:t})}};import Ie from"isomorphic-unfetch";var oe={command:"update <filename>",aliases:["put"],describe:"Insert or update a component definition",builder:e=>d(l(e.positional("filename",{demandOption:!0,describe:"Component definition file to put"}))),handler:async({apiHost:e,apiKey:o,filename:t,project:n})=>{let i=new p({apiKey:o,apiHost:e,fetch:Ie,projectId:n}),s=D(t);await i.updateComponentDefinition({componentDefinition:s})}};var te={command:"component <command>",aliases:["def"],describe:"Commands for Canvas component definitions",builder:e=>e.command(X).command(Z).command(Y).command(ee).command(B).command(oe).demandCommand(),handler:()=>Me.help()};import Ue from"yargs";import Te from"isomorphic-unfetch";var ne={command:"get <id>",describe:"Fetch a composition",builder:e=>j(d(l(S(e.positional("id",{demandOption:!0,describe:"Composition public ID to fetch"}).option({resolvePatterns:{type:"boolean",default:!1,describe:"Resolve pattern references in the composition"}}))))),handler:async({apiHost:e,apiKey:o,id:t,format:n,filename:i,state:s,project:c,resolvePatterns:r})=>{let a=new p({apiKey:o,apiHost:e,fetch:Te,projectId:c}),m=W(await a.getCompositionById({compositionId:t,state:P(s),skipPatternResolution:!r}));h(m,n,i)}};import xe from"isomorphic-unfetch";var ie={command:"list",describe:"List compositions",aliases:["ls"],builder:e=>j(d(l(S(e.options({offset:{describe:"Number of rows to skip before fetching",type:"number",default:0},limit:{describe:"Number of rows to fetch",type:"number",default:20},resolvePatterns:{type:"boolean",default:!1,describe:"Resolve pattern references in the composition"}}))))),handler:async({apiHost:e,apiKey:o,limit:t,offset:n,format:i,filename:s,project:c,state:r,resolvePatterns:a})=>{let g=await new p({apiKey:o,apiHost:e,fetch:xe,projectId:c}).getCompositionList({limit:t,offset:n,state:P(r),skipPatternResolution:!a});h(g.compositions,i,s)}};import ke from"isomorphic-unfetch";var L=e=>e.composition._id,_=e=>{var o,t;return`${(t=(o=e.composition._name)!=null?o:e.composition._slug)!=null?t:e.composition._id} (pid: ${e.composition._id})`};function K({client:e,state:o}){let t=P(o);async function*n(){let i=$(async(s,c)=>(await e.getCompositionList({limit:c,offset:s,state:t,skipPatternResolution:!0})).compositions,{pageSize:100});for await(let s of i)yield{id:L(s),displayName:_(s),providerId:s.composition._id,object:W(s)}}return{objects:n(),deleteObject:async i=>{await e.removeComposition({compositionId:i})},writeObject:async i=>{await e.updateComposition({...i.object,state:t})}}}var re={command:"pull <directory>",describe:"Pulls all compositions to local files in a directory",builder:e=>d(l(S(w(e.positional("directory",{describe:"Directory to save the component definitions to. If a filename ending in yaml or json is used, a package file will be created instead of files in the directory.",type:"string"}).option("format",{alias:["f"],describe:"Output format",default:"yaml",choices:["yaml","json"],type:"string"}).option("what-if",{alias:["w"],describe:"What-if mode reports what would be done but changes no files",default:!1,type:"boolean"}).option("mode",{alias:["m"],describe:'What kind of changes can be made. "create" = create new files, update nothing. "createOrUpdate" = create new files, update existing, delete nothing. "mirror" = create, update, and delete to mirror state',choices:["create","createOrUpdate","mirror"],default:"mirror",type:"string"}))))),handler:async({apiHost:e,apiKey:o,directory:t,format:n,mode:i,whatIf:s,state:c,project:r,diff:a})=>{var y;let m=new p({apiKey:o,apiHost:e,fetch:ke,projectId:r,limitPolicy:v}),g=K({client:m,state:c}),u=O(t),f;if(u){let A=k(t,!1);f=await F({objects:(y=A==null?void 0:A.compositions)!=null?y:[],selectIdentifier:L,selectDisplayName:_,onSyncComplete:async(b,C)=>{A.compositions=C,J(t,A)}})}else f=await I({directory:t,selectIdentifier:L,selectDisplayName:_,format:n});await E({source:g,target:f,mode:i,whatIf:s,log:x({diffMode:a})})}};import Fe from"isomorphic-unfetch";var se={command:"push <directory>",describe:"Pushes all compositions from files in a directory to Uniform Optimize",builder:e=>d(l(S(w(e.positional("directory",{describe:"Directory to read the component definitions from. If a filename is used, a package will be read instead.",type:"string"}).option("what-if",{alias:["w"],describe:"What-if mode reports what would be done but changes nothing",default:!1,type:"boolean"}).option("mode",{alias:["m"],describe:'What kind of changes can be made. "create" = create new, update nothing. "createOrUpdate" = create new, update existing, delete nothing. "mirror" = create, update, and delete',choices:["create","createOrUpdate","mirror"],default:"mirror",type:"string"}))))),handler:async({apiHost:e,apiKey:o,directory:t,mode:n,whatIf:i,state:s,project:c,diff:r})=>{var f;let a=new p({apiKey:o,apiHost:e,fetch:Fe,projectId:c,limitPolicy:v}),m;if(O(t)){let y=k(t,!0);m=await F({objects:(f=y.compositions)!=null?f:[],selectIdentifier:L,selectDisplayName:_})}else m=await I({directory:t,selectIdentifier:L,selectDisplayName:_});let u=K({client:a,state:s});await E({source:m,target:u,mode:n,whatIf:i,log:x({diffMode:r})})}};import Le from"isomorphic-unfetch";var ae={command:"remove <id>",aliases:["delete","rm"],describe:"Delete a composition",builder:e=>d(l(e.positional("id",{demandOption:!0,describe:"Composition public ID to delete"}))),handler:async({apiHost:e,apiKey:o,id:t,project:n})=>{await new p({apiKey:o,apiHost:e,fetch:Le,projectId:n}).removeComposition({compositionId:t})}};import _e from"isomorphic-unfetch";var ce={command:"update <filename>",aliases:["put"],describe:"Insert or update a composition",builder:e=>d(l(S(e.positional("filename",{demandOption:!0,describe:"Composition file to put"})))),handler:async({apiHost:e,apiKey:o,filename:t,project:n,state:i})=>{let s=new p({apiKey:o,apiHost:e,fetch:_e,projectId:n}),c=D(t);await s.updateComposition({...c,state:P(i)})}};var me={command:"composition <command>",describe:"Commands for Canvas compositions",aliases:["comp"],builder:e=>e.command(re).command(se).command(ne).command(ae).command(ie).command(ce).demandCommand(),handler:()=>Ue.help()};var Bn={commands:[{command:"canvas <command>",aliases:["cv","pm","presentation"],describe:"Uniform Canvas commands",builder:e=>e.command(me).command(te).demandCommand(),handler:()=>{Ne.showHelp()}}]};export{k as readCanvasPackage,Bn as uniformCLI,J as writeCanvasPackage};
