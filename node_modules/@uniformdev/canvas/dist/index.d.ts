import { C as ComponentInstance, a as ComponentParameter, b as CompositionAPIOptions, c as CompositionListAPIResponse, d as CompositionAPIResponse, e as CompositionAPIPutRequest, f as CompositionAPIDeleteRequest, g as ComponentDefinitionListAPIOptions, h as ComponentDefinitionAPIResponse, i as ComponentDefinitionAPIPutRequest, j as ComponentDefinitionAPIDeleteRequest, P as PreviewEventBus } from './createEventBus-ada6f4ff';
export { q as ChannelSubscription, n as ComponentDefinition, j as ComponentDefinitionAPIDeleteRequest, i as ComponentDefinitionAPIPutRequest, h as ComponentDefinitionAPIResponse, g as ComponentDefinitionListAPIOptions, k as ComponentDefinitionParameter, m as ComponentDefinitionSlot, l as ComponentDefinitionVariant, C as ComponentInstance, a as ComponentParameter, f as CompositionAPIDeleteRequest, b as CompositionAPIOptions, e as CompositionAPIPutRequest, d as CompositionAPIResponse, p as CompositionFetchState, c as CompositionListAPIResponse, o as CreatingComponentDefinition, P as PreviewEventBus, R as RootComponentInstance, r as createEventBus } from './createEventBus-ada6f4ff';
import { Options } from 'p-throttle';
import { Options as Options$1 } from 'p-retry';
import { PersonalizableListItem } from '@uniformdev/optimize-tracker-common';
import 'pusher-js';

declare type EnhancerContext = {
    preview?: boolean;
};
/** Options passed to a ComponentEnhancer function */
declare type ComponentEnhancerOptions<TContext extends EnhancerContext = EnhancerContext> = {
    component: Readonly<ComponentInstance>;
    context: TContext;
};
/**
 * A function which is called for each matching component in a composition, which can manipulate the value of a specific key in the component's `data` property.
 * Used to enhance layout data with information from other platforms, such as private APIs, where the value is not tied to a parameter
 * and is intrinsic to the component itself.
 *
 * Note: the configuration of enhancers namespaces component enhancers into a named property on the data object to avoid collisions,
 * thus an enhancer need not worry about merging values with other enhancers, nor which key it has been registered under.
 *
 * Return values:
 * TValue - sets the configured key in the component's data value to this value
 * undefined - do not set the component's data key
 */
declare type ComponentEnhancerFunction<TValue = unknown, TContext extends EnhancerContext = EnhancerContext> = (options: ComponentEnhancerOptions<TContext>) => Promise<TValue | undefined> | TValue | undefined;
/**
 * Defines logic to add arbitrary async data to a component's `data` property.
 * Used to enhance layout data with information from other platforms, such as private APIs,
 * where the value is not tied to a parameter and is intrinsic to the component itself.
 */
declare type ComponentEnhancer<TValue = unknown, TContext extends EnhancerContext = EnhancerContext> = {
    /** Function called to enhance a single component in a composition. */
    enhanceOne: ComponentEnhancerFunction<TValue, TContext>;
    /**
     * The limit policy that defines how much concurrency and retry is allowed for this enhancer.
     * If the enhancer does not define completeAll(), this limit policy is applied to enhanceOne() calls.
     * If the enhancer does define completeAll(), this limit policy is applied to the completeAll() calls.
     * If the limit policy is undefined, unbounded concurrency is allowed and no error retrying will occur.
     */
    limitPolicy?: LimitPolicy;
    completeAll?: () => Promise<void>;
};
/** Options passed to a ComponentParameterEnhancer function */
declare type ComponentParameterEnhancerOptions<TRawValue = unknown, TContext extends EnhancerContext = EnhancerContext> = {
    parameter: Readonly<ComponentParameter<TRawValue>>;
    parameterName: string;
    component: Readonly<ComponentInstance>;
    context: TContext;
};
/**
 * A function which is called for each component parameter in a component tree, which can manipulate the value of the parameter.
 * Used to enhance layout data with information from other platforms, such as CMS, commerce, indexing, etc.
 *
 * Return values:
 * TValue - replaces the original parameter value with this value
 * undefined - do not change the original parameter value
 * null - sets the parameter value to null, replacing any existing value (i.e. if its value could not be resolved in an external system)
 */
declare type ComponentParameterEnhancerFunction<TRawValue = unknown, TOutputValue = unknown, TContext extends EnhancerContext = EnhancerContext> = (options: ComponentParameterEnhancerOptions<TRawValue, TContext>) => Promise<TOutputValue | undefined | null> | TOutputValue | undefined | null;
/**
 * Defines logic to replace the value of a component parameter with arbitrary async data.
 * Used to enhance layout data with information from other platforms, such as CMS, commerce, indexing, etc,
 * where that data is directly expandable from a parameter value.
 */
declare type ComponentParameterEnhancer<TRawValue = unknown, TOutputValue = unknown, TContext extends EnhancerContext = EnhancerContext> = {
    /** Function called to enhance a single parameter to be enhanced. */
    enhanceOne: ComponentParameterEnhancerFunction<TRawValue, TOutputValue, TContext>;
    /**
     * The limit policy that defines how much concurrency and retry is allowed for this enhancer.
     * If the enhancer does not define completeAll(), this limit policy is applied to enhanceOne() calls.
     * If the enhancer does define completeAll(), this limit policy is applied to the completeAll() calls.
     * If the limit policy is undefined, unbounded concurrency is allowed and no error retrying will occur.
     */
    limitPolicy?: LimitPolicy;
    /**
     * Function called, if defined, after all enhanceOne() calls have completed for the composition being enhanced.
     * Used to enable batching.
     * Return the number of batched items processed (or zero if that does not apply).
     */
    completeAll?: () => Promise<number>;
};

declare type ComponentLocationReference = {
    component: ComponentInstance;
    parentSlot?: string;
    parentSlotIndex?: number;
};
declare type WalkComponentTreeActions = {
    replaceComponent: (replacementComponent: ComponentInstance) => void;
    removeComponent: () => void;
    insertAfter: (components: ComponentInstance | ComponentInstance[]) => void;
};
/** Walks a composition's component tree, visiting each component instance depth-first, in order. */
declare function walkComponentTree(component: ComponentInstance, visitor: (component: ComponentInstance, ancestorsAndSelf: Array<ComponentLocationReference>, actions: WalkComponentTreeActions) => void): void;
declare function getComponentPath(ancestorsAndSelf: Array<ComponentLocationReference>): string;

/** A single entry in a batch of queued enhancements. */
declare class BatchEntry<TArgs, TResult> {
    private _resolve;
    private _reject;
    args: TArgs;
    private _isCompleted;
    constructor(_resolve: (result: TResult) => void, _reject: (reason: any) => void, args: TArgs);
    /** Mark the batch entry as successfully completed. */
    resolve(result: TResult): void;
    /** Mark the batch entry as failed. */
    reject(reason: any): void;
    /** @return Whether the batch entry has been completed (resolved or rejected). */
    get isCompleted(): boolean;
}
/**
 * An enhancer that queues up promises for each component that needs enhancing,
 * and once all enhancements have been queued handles them all in a batch.
 * Note: this type is adaptable to both ComponentParameterEnhancer and ComponentEnhancer types.
 */
declare type BatchEnhancer<TArgs, TResult> = {
    /** Adds a promise to the enhancement queue. */
    enhanceOne: (args: TArgs) => Promise<TResult | undefined>;
    /** Calls the batch enhancer function for all queued promises and resolves them. Returns number of processed items. */
    completeAll: () => Promise<number>;
    limitPolicy?: LimitPolicy;
};
/**
 * Creates an enhancer that batches up all enhancements for a composition into a set of promises,
 * and then handles them all in a single batch. Used to reduce the number of HTTP requests
 * needed to fulfill layout enhancements when a layout uses many resources from other systems.
 */
declare function createBatchEnhancer<TArgs, TResult>({ handleBatch, shouldQueue, limitPolicy, }: {
    /** Function called to handle one or more batched up enhancements. (note: queue will never be an empty array) */
    handleBatch: (queue: ReadonlyArray<Readonly<BatchEntry<TArgs, TResult>>>) => Promise<void>;
    /** Function called to determine if a given enhancement should be queued, i.e. don't queue invalid or null/undefined values. */
    shouldQueue?: (args: TArgs) => boolean;
    limitPolicy?: LimitPolicy;
}): BatchEnhancer<TArgs, TResult>;

/**
 * Given a batch of enhancements containing potentially duplicate entries (i.e. several components referencing the same thing),
 * group them together by some unique identifier and enable simpler batch processing.
 */
declare class UniqueBatchEntries<TArgs, TResult> {
    groups: Readonly<Record<string, ReadonlyArray<Readonly<BatchEntry<TArgs, TResult>>>>>;
    constructor(
    /** The batch queue being processed. */
    entries: ReadonlyArray<Readonly<BatchEntry<TArgs, TResult>>>, 
    /** A function to select the unique identifier for a given batch entry. */
    uniqueKeySelector: (entry: Readonly<TArgs>) => string);
    /** Resolves all entries in a group key with the same result value. */
    resolveKey(key: string, result: TResult): void;
    /** Resolves all remaining entries that have not been otherwise resolved with a specific value */
    resolveRemaining(value: TResult): void;
}

/**
 * Builds a definition of the enhancers to run on Canvas components to add data from other systems.
 * Note that only the first matching enhancer will be run.
 */
declare class ChildEnhancerBuilder {
    private _paramMatches;
    private _dataMatches;
    /** Targets an enhancer to modify the value of any parameter */
    parameter(enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>): this;
    /** Targets an enhancer to modify the value of any parameter with a specific name */
    parameterName(name: string | readonly string[], enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>): this;
    /** Targets an enhancer to modify the value of any parameter with a specific type */
    parameterType(type: string | readonly string[], enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>): this;
    /**
     * Targets an enhancer to set a specific object key on the component's `data` property.
     * Note: an exception will be thrown if the same key is registered more than once.
     */
    data(name: string, enhancer: ComponentEnhancer<any> | ComponentEnhancerFunction<any>): this;
    /**
     * Resolves the parameter enhancer for a given parameter, if one exists.
     * The first matching enhancer by registration order is returned, if more than one could match.
     */
    resolveParameterEnhancer(parameterName: string, parameter: ComponentParameter): ComponentParameterEnhancer<unknown, unknown, EnhancerContext> | undefined;
    /**
     * Resolves component enhancer(s) for a given component.
     * Returns a Map where the key is the name of the data property and the value is the enhancer.
     */
    resolveComponentEnhancers(): Map<string, ComponentEnhancer<unknown, EnhancerContext>>;
    private _resolveParameterEnhancer;
}
/**
 * Builds a definition of the enhancers to run on Canvas components to add data from other systems.
 * Note that only the first matching enhancer will be run.
 */
declare class EnhancerBuilder {
    private _componentIndex;
    private _rootBuilder;
    /** Targets an enhancer to modify the value of any parameter */
    parameter(enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction): this;
    /** Targets an enhancer to modify the value of any parameter with a specific name */
    parameterName(name: string | readonly string[], enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction): this;
    /** Targets an enhancer to modify the value of any parameter with a specific type */
    parameterType(type: string | readonly string[], enhancer: ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>): this;
    /**
     * Targets an enhancer to set a specific object key on the component's `data` property.
     * Note: an exception will be thrown if the same key is registered more than once.
     */
    data(name: string, enhancer: ComponentEnhancer<any> | ComponentEnhancerFunction<any>): this;
    /**
     * Targets a subset of enhancers at a specific component type.
     * Global enhancers will still be run if no matching enhancer is registered for this component's properties.
     */
    component(name: string | readonly string[], builder: (builder: ChildEnhancerBuilder) => void): EnhancerBuilder;
    /**
     * Resolves the parameter enhancer for a given parameter, if one exists.
     * The first matching enhancer by registration order is returned, if more than one could match.
     */
    resolveParameterEnhancer(component: ComponentInstance, parameterName: string, parameter: ComponentParameter): ComponentParameterEnhancer<unknown, unknown, EnhancerContext> | undefined;
    /**
     * Resolves component enhancer(s) for a given component.
     * Returns a Map where the key is the name of the data property and the value is the enhancer.
     */
    resolveComponentEnhancers(component: ComponentInstance): Map<string, ComponentEnhancer<unknown, EnhancerContext>>;
}

declare type EnhancerError = {
    message: string;
    error: Error | string;
};
/**
 * Applies enhancer functions to a component tree.
 * IMPORTANT: the input composition object is mutated. Plan accordingly.
 * Want immutability? Grab immer :)
 */
declare function enhance<TContext extends EnhancerContext = EnhancerContext>({ composition, enhancers, context, onErrors, }: {
    composition: ComponentInstance;
    enhancers: EnhancerBuilder;
    context: TContext;
    onErrors?: (errors: EnhancerError[]) => void;
}): Promise<void>;

/**
 * Composes several enhancers into a synchronous chain. Can be used to modify the output of an enhancer.
 * NOTE: only the first enhancer in the chain may use batching (completeAll()).
 */
declare const compose: (input: ComponentParameterEnhancer<any, any>, ...composers: ReadonlyArray<ComponentParameterEnhancer<any, any> | ComponentParameterEnhancerFunction<any>>) => ComponentParameterEnhancer<any, any>;

declare type LimitPolicy = <ReturnValue>(func: () => Promise<ReturnValue>) => Promise<ReturnValue>;
declare function createLimitPolicy({ throttle, retry, }: {
    throttle?: Options | false;
    retry?: Options$1 | false;
}): LimitPolicy;
declare const nullLimitPolicy: LimitPolicy;

declare type CanvasClientOptions = {
    /** The Uniform API host to use. Internal use. */
    apiHost?: string;
    /** The Uniform API key to use when sending API requests. This or bearer token must be specified. */
    apiKey?: string | null;
    /** The Uniform bearer token to use. Internal use. */
    bearerToken?: string | null;
    /** The Uniform project ID to connect to */
    projectId?: string | null;
    /** Specify a fetch implementation to use when fetching data. Useful if you want to only polyfill selectively. */
    fetch?: typeof fetch;
    /**
     * Specify how to retry and throttle requests.
     * Default: retry 3x on failures with exponential backoff, up to 10 requests per second.
     * Use createLimitPolicy() to help creating a policy. */
    limitPolicy?: LimitPolicy;
};
declare class CanvasClientError extends Error {
    errorMessage: string;
    fetchMethod: string;
    fetchUri: string;
    statusCode?: number | undefined;
    statusText?: string | undefined;
    constructor(errorMessage: string, fetchMethod: string, fetchUri: string, statusCode?: number | undefined, statusText?: string | undefined);
}
declare class CanvasClient {
    private options;
    constructor(options: CanvasClientOptions);
    /** Fetches lists of Canvas compositions, optionally by type */
    getCompositionList(options?: Omit<CompositionAPIOptions, 'projectId'>): Promise<CompositionListAPIResponse>;
    /** Fetches a Canvas composition by string name (slug) */
    getCompositionBySlug(options: Pick<CompositionAPIOptions, 'slug' | 'state' | 'skipEnhance' | 'skipPatternResolution'>): Promise<CompositionAPIResponse>;
    /** Fetches a Canvas composition by its public UUID */
    getCompositionById(options: Pick<CompositionAPIOptions, 'compositionId' | 'state' | 'skipEnhance' | 'skipPatternResolution'>): Promise<CompositionAPIResponse>;
    /** Updates or creates a Canvas component definition */
    updateComposition(body: Omit<CompositionAPIPutRequest, 'projectId'>): Promise<void>;
    /** Deletes a Canvas component definition */
    removeComposition(body: Omit<CompositionAPIDeleteRequest, 'projectId'>): Promise<void>;
    /** Fetches all Canvas component definitions */
    getComponentDefinitions(options?: Omit<ComponentDefinitionListAPIOptions, 'projectId'>): Promise<ComponentDefinitionAPIResponse>;
    /** Updates or creates a Canvas component definition */
    updateComponentDefinition(body: Omit<ComponentDefinitionAPIPutRequest, 'projectId'>): Promise<void>;
    /** Deletes a Canvas component definition */
    removeComponentDefinition(body: Omit<ComponentDefinitionAPIDeleteRequest, 'projectId'>): Promise<void>;
    private apiClient;
    private createUrl;
}

/** Public ID of Canvas personalization component type */
declare const CANVAS_PERSONALIZE_TYPE = "$personalization";
/** Public ID of Canvas A/B test component type */
declare const CANVAS_TEST_TYPE = "$test";
/** Public ID of Canvas localization component type */
declare const CANVAS_LOCALIZATION_TYPE = "$localization";
/** Public ID of the intent tag parameter on the Canvas personalization component type */
declare const CANVAS_INTENT_TAG_PARAM = "intentTag";
/** Public ID of the locale parameter on Canvas components */
declare const CANVAS_LOCALE_TAG_PARAM = "locale";
/** Name of the slot on CANVAS_PERSONALIZE_TYPE */
declare const CANVAS_PERSONALIZE_SLOT = "pz";
/** Name of the slot on CANVAS_TEST_TYPE */
declare const CANVAS_TEST_SLOT = "test";
/** Name of the slot on CANVAS_TEST_TYPE */
declare const CANVAS_LOCALIZATION_SLOT = "localized";
/** Constant for a draft composition state. Subject to change. */
declare const CANVAS_DRAFT_STATE = 0;
/** Constatnt for a published composition state. Subject to change. */
declare const CANVAS_PUBLISHED_STATE = 64;

/** Determines if a given Canvas component type is a system-defined type */
declare const isSystemComponentDefinition: (componentType: string) => boolean;

/**
 * Converts components in a slot into personalized variations (based on each component's intent tag in Canvas) suitable to pass to a personalize component
 * Useful when implementing custom personalization settings for Canvas components.
 */
declare function mapSlotToPersonalizedVariations(slot: ComponentInstance[] | undefined): Array<ComponentInstance & PersonalizableListItem>;

declare function getChannelName(projectId: string, compositionId: string, state: number): string;

declare type EventNames = 'updated';

declare type SubscribeToCompositionOptions = {
    projectId: string;
    compositionId: string;
    compositionState: number;
    callback: (data: unknown) => void;
    eventBus: PreviewEventBus;
    event: EventNames;
};
declare type UnsubscribeCallback = () => void;
/** Subscribes to a composition event */
declare function subscribeToComposition({ projectId, compositionId, compositionState, eventBus: { subscribe }, callback, event, }: SubscribeToCompositionOptions): UnsubscribeCallback;

declare function extractLocales({ component }: {
    component: ComponentInstance;
}): Record<string, ComponentInstance[]>;
declare function localize({ composition, locale, }: {
    composition: ComponentInstance;
    locale: string | ((options: {
        component: Readonly<ComponentInstance>;
        locales: Readonly<Record<string, ComponentInstance[]>>;
    }) => string | undefined);
}): void;

export { BatchEnhancer, BatchEntry, CANVAS_DRAFT_STATE, CANVAS_INTENT_TAG_PARAM, CANVAS_LOCALE_TAG_PARAM, CANVAS_LOCALIZATION_SLOT, CANVAS_LOCALIZATION_TYPE, CANVAS_PERSONALIZE_SLOT, CANVAS_PERSONALIZE_TYPE, CANVAS_PUBLISHED_STATE, CANVAS_TEST_SLOT, CANVAS_TEST_TYPE, CanvasClient, CanvasClientError, CanvasClientOptions, ChildEnhancerBuilder, ComponentEnhancer, ComponentEnhancerFunction, ComponentEnhancerOptions, ComponentLocationReference, ComponentParameterEnhancer, ComponentParameterEnhancerFunction, ComponentParameterEnhancerOptions, EnhancerBuilder, EnhancerContext, EnhancerError, EventNames, LimitPolicy, SubscribeToCompositionOptions, UniqueBatchEntries, UnsubscribeCallback, compose, createBatchEnhancer, createLimitPolicy, enhance, extractLocales, getChannelName, getComponentPath, isSystemComponentDefinition, localize, mapSlotToPersonalizedVariations, nullLimitPolicy, subscribeToComposition, walkComponentTree };
